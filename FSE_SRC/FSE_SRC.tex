\documentclass{sig-alternate-05-2015}

\usepackage{graphicx}
\usepackage{url}
\usepackage{enumitem}
\usepackage{caption}
\usepackage{listings}
\usepackage{textcomp}

\lstset{basicstyle=\scriptsize\ttfamily, 
        captionpos=b, 
        escapeinside={<@}{@>},
        aboveskip=1pt}
\usepackage{xcolor}
\newcommand\todo[1]{\textbf{\textcolor{red}{#1}}}
\newcommand{\lstul}[1]{\underline{\mbox{\tt #1}}}

%\toappear{}
\makeatletter
\def\@copyrightspace{\relax}
\makeatother
\begin{document}

% Copyright
%\setcopyright{acmcopyright}
%\setcopyright{acmlicensed}
%\setcopyright{rightsretained}
%\setcopyright{usgov}
%\setcopyright{usgovmixed}
%\setcopyright{cagov}
%\setcopyright{cagovmixed}


\title{Automatic Trigger Generation for End User Written Rules for Home Automation}
%
% You need the command \numberofauthors to handle the 'placement
% and alignment' of the authors beneath the title.
%
% For aesthetic reasons, we recommend 'three authors at a time'
% i.e. three 'name/affiliation blocks' be placed beneath the title.
%
% NOTE: You are NOT restricted in how many 'rows' of
% "name/affiliations" may appear. We just ask that you restrict
% the number of 'columns' to three.
%
% Because of the available 'opening page real-estate'
% we ask you to refrain from putting more than six authors
% (two rows with three columns) beneath the article title.
% More than six makes the first-page appear very cluttered indeed.
%
% Use the \alignauthor commands to handle the names
% and affiliations for an 'aesthetic maximum' of six authors.
% Add names, affiliations, addresses for
% the seventh etc. author(s) as the argument for the
% \additionalauthors command.
% These 'additional authors' will be output/set for you
% without further effort on your part as the last section in
% the body of your article BEFORE References or any Appendices.

\numberofauthors{1} %  in this sample file, there are a *total*
% of EIGHT authors. SIX appear on the 'first-page' (for formatting
% reasons) and the remaining two appear in the \additionalauthors section.
%
\author{
% 1st. author
\alignauthor
Chandrakana Nandi\\
	\affaddr{Department of Computer Science and Engineering}\\
       \affaddr{University of Washington, Seattle}\\
       \email{cnandi@cs.washington.edu}
%Anonymous submission
}

\maketitle
\begin{abstract}
To customize the behavior of a smart home, an end user writes rules.
When an external event triggers the rule, it executes; for example, when
the temperature is above a certain threshold, then window awnings might be extended.
End users often write incorrect rules~\cite{Huang}.
This paper's technique prevents a certain type of mistake:  
\textit{errors due to too few triggers}.
It statically analyzes a rule's actions to determine what triggers are necessary. We have implemented the technique as a tool named TrigGen and tested it on 116 end-user written rules for an open-source home automation platform called openHAB.
TrigGen identified that 66\% of the rules had fewer triggers than required
for correct behavior.
The missing triggers could lead to unexpected behavior
and security vulnerabilities in a smart home.
\end{abstract}

\printccsdesc

\section{Research problem}
Most home automation platforms support end-user customization components: a user writes rules to determine what actions should be taken by what device under what conditions~\cite{Newmannowwere}. A recent study~\cite{practical-tap} has shown that rule-based systems are one of the most practical solutions for enabling end-users to customize the behavior of their smart homes. A rule-based language has two main components: triggers that cause a rule to be fired and actions to be executed when a rules fires. 
\begin{lstlisting}[caption={Rule for setting the Away or Sleeping state.},label={lst:away}]
rule "Away rule"
when
  // trigger block
  Item State_Away changed 	
then
  // action block	
  if(State_Away.state == ON){
    if(State_Sleeping.state != OFF){
      postUpdate(State_Sleeping,OFF)
    }
  }
end
\end{lstlisting}
Listing~\ref{lst:away} shows an example of a rule. The part between \texttt{when} and \texttt{then} is the trigger block and the part between \texttt{then} and \texttt{end} is the action block. This programming paradigm is also called Trigger Action Programming (TAP). Even though TAP is the most commonly used and practical approach for home automation, end users often make errors in writing trigger-action programs~\cite{Huang},\cite{wild-tap}. These errors could be in 1) writing the triggers, or 2) writing the actions or 3) both. In a heterogeneous system like a smart home where there are multiple interacting devices, it is common for the rules to interact. As a result, an error in one rule can propagate to others and cause unexpected behavior or security vulnerabilities in different parts of the house. In this paper, we propose a solution to make it easier for the end users to write home automation rules correctly. Our approach eliminates one category of errors in the rules---\textit{errors due to too few triggers}. By doing a static analysis of the actions, our approach automatically generates the trigger conditions so that the user does not have to worry about including the \textit{correct} and \textit{sufficient number} of triggers in the rules. 
Consider the rule which is written by an end user in listing~\ref{lst:away}. This rule is supposed to set the value of \texttt{State\_Away} to \texttt{ON} when no one is in the house. It also sets \texttt{State\_Sleeping} to \texttt{OFF} if it currently \texttt{ON} so that  \texttt{State\_Away} and \texttt{State\_Sleeping} are not \texttt{ON} simultaneously. However, the trigger for this rule only contains \texttt{State\_Away}. As a result, this rule is only fired when \texttt{State\_Away} changes. However, if the value of \texttt{State\_Sleeping} changes after the value of \texttt{State\_Away}, then the rule is not fired due to which, it allows both values to be set at the same time. This deviates from the expected behavior of the rule---it is no longer clear whether the home inhabitants are away or inside sleeping. This example shows that even if the action block of a rule is implemented correctly, not having all the correct triggers can lead to too few firings of the rule and thus, unexpected behavior. 
We implemented our technique as a tool named TrigGen and used it to analyse 116 home automation rules written by end users---TrigGen found 66\% rules to be vulnerable and deviating from the expected behavior due to lack of trigger conditions.

\section{Related work}
Security loopholes in smart homes have been investigated in several papers~\cite{yoshi, dhanjani, jung, todayToTomorrow}. Recently, Fernandes et al.\cite{smartthings16} did a  security analysis of several apps based on Samsung SmartThings and discovered that many of them unnecessarily granted full access to the devices in the house. While they aimed at identifying security flaws in the SmartThings framework itself, our aim is to assist end users in writing correct automation rules and we do so by automatically generating the trigger conditions.  Further, instead of analysing apps for home automation, we analysed end user written rules which are mostly written by non-programmers. Some work has been done on detecting conflicts in trigger-action programs~\cite{rvs, homer, utea}. In addition to detecting conflicts in triggers, TrigGen is capable of automatically generating the correct triggers for a rule which makes it unique and different from previous work.

\section{Approach}
We have developed a static technique to automatically generate correct event-based triggers from the actions written by the end users. Our tool, TrigGen has three features--- 1) generating all event-based triggers, 2) detecting missing triggers when some of them are already written by the end user, and 3) detecting conflicts by identifying all rules which try to write to the same item. 
Figure~\ref{fig:design} shows the design of our tool. It takes as input a \textit{rule} file which contains all the end user written rules and an \textit{item} file which contains a list of all the smart devices (or items) installed in the home. 

The rule file is parsed to extract the action block and the item file is parsed to extract all the item names, types (\texttt{Switches}, \texttt{Shutters}, \texttt{Dimmers} etc.), and the groups to which they belong; for example all the light switches in the living room may be grouped together.

By statically analysing the abstract syntax tree of the action block, $A$, TrigGen first identifies all the items that appear in a rule, $R$. This is an exhaustive list of all potential event-based triggers. Let this list be $T$.
Naively adding all $t \in T$ as triggers of $R$ would either unnecessarily fire $R$ too many time or add redundant triggers. Hence, we apply an elimination technique to get rid of triggers that are not required. For that, we define the following terms.

\emph{Definition 1}. An item is \emph{live} in $R$ if its value is read before it is written to in the action block, $A$. 

\emph{Definition 2}. An item is \emph{dependent} in $R$ if its value is computed based on other items or local variables in the rule---this implies that the item is \emph{not live}. 
 
\emph{Definition 3}. An item is \emph{independent} in $R$ if  its value is directly obtained from a sensor or a user's input and not computed based on any other item or variable---this implies that the item is \emph{live} in $R$. 

\emph{Definition 4}. An event-based trigger is \emph{redundant} if inclusion of the trigger in a rule \emph{never} changes the state of any item or the value of any variable involved in $S$ when the rule is fired due to it.

\emph{Trigger elimination strategy.} \textbf{ An item $d$ which is not \emph{live} in $R$ is not included in $T$ because it is \emph{redundant}. As a corollary, if $d$ is \emph{dependent}, it is also not included in $T$.} 

\emph{Conflicting rules.} Two or more rules are said to have a conflict for an item if they all write to the item. TrigGen can detect such conflicts between every pair of rules and warn the end user for potential conflicts. 
\begin{figure}
\centering
\includegraphics [trim=2cm 18cm 0 5.5cm, scale=0.45]{images/design.pdf}
\caption{Design of TrigGen: ruleParser and itemParser parse the rule and item files respectively to extract useful information. This information goes to the core trigger generator component which enumerates all possible triggers and eliminates redundant ones. If some of the triggers are already written by the end user, TrigGen can detect the missing ones. }
\label{fig:design}
\end{figure} 
 
\section{Experimental Results}
We evaluated our tool on 116 end user written rules. We obtained the rules from links provided on the openHAB website~\cite{data1},\cite{data2}. It took $\sim$ 7.12 ms for the tool to generate the triggers and find the missing triggers for all the rules. For 109 rules, our tool suggested a list of all required event-based triggers and for 77 rules, our tool found missing triggers when some triggers were already provide by the users. The maximum number of triggers TrigGen found for a rule is 27. Figure~\ref{fig:graph} shows the output of TrigGen for suggesting triggers.
For 18 rules, our tool detected potential conflicts among one or more rules. The maximum number of conflicting rules TrigGen found for an item is 2. 
\begin{figure}[h]
\centering
\includegraphics [trim=1cm 0 0 0, scale=0.6]{images/graph.png}
\caption{Summary of the output of TrigGen for suggesting triggers. The x-axis shows the number of triggers and the y-axis shows the number of rules.}
\label{fig:graph}
\end{figure} 

\section{Conclusions}
Not surprisingly, our research shows that end user written rules are often incorrect. We observed that a common error made by end users while writing the rules is having insufficient number of triggers, leading to fewer firings of the rules than necessary. To prevent this problem, we developed a tool that can automatically generate trigger conditions based on the actions in a rule as well as identify missing triggers if some of them are already provided. This reduces the burden of the end users by assisting them in including all the required triggers. \\
\emph{Scope.} Some rules are meant to be fired under temporal triggers only (such as at a certain time of the day). While our tool is capable of generating all event-based triggers, it cannot generate such temporal triggers. This is because it runs directly on the rules without any additional annotations from the end users about their preferences and without that, it is impossible to infer the exact temporal triggers the user expects. 

\bibliographystyle{abbrv}
\bibliography{sigproc}  

\end{document}
